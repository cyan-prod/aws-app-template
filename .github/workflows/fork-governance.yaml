name: Fork Governance

on:
  fork:
  workflow_dispatch:
    inputs:
      target_repo:
        description: 'Target repository name (e.g., aws-app-Test)'
        required: false
        default: 'aws-app-Test'
        type: string
      nuke_repo:
        description: 'Nuke repository before applying governance (removes all files, sets default to main, deletes dev branch)'
        required: false
        default: true
        type: boolean

jobs:
  setup-forked-repo:
    name: Apply governance to forked repository
    runs-on: ubuntu-latest
    steps:
      - name: Checkout template repository
        uses: actions/checkout@v5

      - name: Nuke target repository completely
        if: ${{ github.event.inputs.nuke_repo == 'true' }}
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_PAT_CLASSIC }}
          script: |
            const forkOwner = '${{ github.event.inputs.target_repo && 'cyan-prod' || github.event.forkee.owner.login }}';
            const forkRepo = '${{ github.event.inputs.target_repo || github.event.forkee.name }}';

            console.log(`üî• NUKING ${forkOwner}/${forkRepo} completely...`);

            try {
              // 1. Delete all existing rulesets
              console.log('üóëÔ∏è Deleting all rulesets...');
              const rulesets = await github.rest.repos.getRepoRulesets({
                owner: forkOwner,
                repo: forkRepo
              });

              for (const ruleset of rulesets.data) {
                await github.rest.repos.deleteRepoRuleset({
                  owner: forkOwner,
                  repo: forkRepo,
                  ruleset_id: ruleset.id
                });
                console.log(`‚úì Deleted ruleset: ${ruleset.name}`);
              }

              // 2. Delete all issues
              console.log('üóëÔ∏è Deleting all issues...');
              const issues = await github.rest.issues.listForRepo({
                owner: forkOwner,
                repo: forkRepo,
                state: 'all',
                per_page: 100
              });

              for (const issue of issues.data) {
                await github.rest.issues.update({
                  owner: forkOwner,
                  repo: forkRepo,
                  issue_number: issue.number,
                  state: 'closed'
                });
                console.log(`‚úì Closed issue #${issue.number}: ${issue.title}`);
              }

              console.log(`‚úì Closed ${issues.data.length} issues`);

              // 3. Set default branch back to main first
              console.log('üîÑ Setting default branch to main...');
              await github.rest.repos.update({
                owner: forkOwner,
                repo: forkRepo,
                default_branch: 'main'
              });
              console.log('‚úì Set default branch to main');

              // 4. Delete dev branch if it exists
              console.log('üóëÔ∏è Deleting dev branch...');
              try {
                await github.rest.git.deleteRef({
                  owner: forkOwner,
                  repo: forkRepo,
                  ref: 'heads/dev'
                });
                console.log('‚úì Deleted dev branch');
              } catch (error) {
                if (error.status === 422) {
                  console.log('Dev branch does not exist or is protected');
                } else {
                  console.log('Failed to delete dev branch:', error.message);
                }
              }

              // 5. Sync from upstream template
              console.log('üîÑ Syncing from upstream template...');

              // Get the latest commit from the template repository
              const templateMain = await github.rest.repos.getBranch({
                owner: 'cyan-prod',
                repo: 'aws-app-template',
                branch: 'main'
              });

              // Force update the forked repo to match template
              await github.rest.git.updateRef({
                owner: forkOwner,
                repo: forkRepo,
                ref: 'heads/main',
                sha: templateMain.data.commit.sha,
                force: true
              });

              console.log('‚úì Synced from upstream template');
              console.log(`üî• ${forkOwner}/${forkRepo} has been completely NUKED and synced!`);
              console.log(`üõë Workflow stopped - repository is ready for testing`);

              // Stop the workflow by exiting with code 1
              process.exit(1);

            } catch (error) {
              console.log('Repository nuking failed:', error.message);
              console.log(`üõë Workflow stopped anyway - repository is ready for testing`);

              // Stop the workflow by exiting with code 1 (even on error)
              process.exit(1);
            }

      - name: Get repository details
        id: repo-info
        uses: actions/github-script@v8
        with:
          script: |
            let repoOwner, repoName, repoFullName, repoUrl;

            if (context.eventName === 'fork') {
              // Fork event - get details from payload
              repoOwner = context.payload.forkee.owner.login;
              repoName = context.payload.forkee.name;
              repoFullName = context.payload.forkee.full_name;
              repoUrl = context.payload.forkee.html_url;
              console.log(`Fork detected: ${repoFullName}`);
            } else if (context.eventName === 'workflow_dispatch') {
              // Manual dispatch - use input with cyan-prod as owner
              repoName = '${{ github.event.inputs.target_repo }}';
              repoOwner = 'cyan-prod';
              repoFullName = `${repoOwner}/${repoName}`;
              repoUrl = `https://github.com/${repoFullName}`;
              console.log(`Manual dispatch for: ${repoFullName}`);
            }

            console.log(`Repository: ${repoFullName}`);
            console.log(`URL: ${repoUrl}`);

            core.setOutput('owner', repoOwner);
            core.setOutput('repo', repoName);
            core.setOutput('full_name', repoFullName);
            core.setOutput('url', repoUrl);

      - name: Validate repository naming convention
        id: validate-name
        uses: actions/github-script@v8
        with:
          script: |
            const repoName = '${{ steps.repo-info.outputs.repo }}';
            const namePattern = /^aws-[a-z0-9]+(-[a-z0-9]+)*$/;

            console.log(`Validating repository name: ${repoName}`);

            if (!namePattern.test(repoName)) {
              console.log('‚ùå Repository name does NOT follow convention');

              let issues = [];

              if (!repoName.startsWith('aws-')) {
                issues.push('Must start with "aws-"');
              }

              if (repoName !== repoName.toLowerCase()) {
                issues.push('Must be all lowercase');
              }

              if (repoName.includes('_')) {
                issues.push('Use hyphens (-) not underscores (_)');
              }

              if (/[A-Z]/.test(repoName)) {
                issues.push('No uppercase letters allowed');
              }

              const suggestion = repoName
                .toLowerCase()
                .replace(/[_\s]+/g, '-')
                .replace(/^(?!aws-)/, 'aws-');

              core.setOutput('valid', 'false');
              core.setOutput('issues', issues.join('; '));
              core.setOutput('suggestion', suggestion);
            } else {
              console.log('‚úì Repository name follows convention');
              core.setOutput('valid', 'true');
            }

      - name: Clean up governance files on main branch
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_PAT_CLASSIC }}
          script: |
            const forkOwner = '${{ steps.repo-info.outputs.owner }}';
            const forkRepo = '${{ steps.repo-info.outputs.repo }}';

            console.log('Cleaning up template-specific files from main branch...');

            // Files to delete (no longer needed in forked repos)
            // Edit this list directly to add/remove files
            const filesToDelete = [
              'rulesets/main.json',
              'rulesets/dev.json',
              'rulesets/tag-protection.json',
              'rulesets/branch-naming.json',
              'rulesets/commit-message.json',
              'rulesets/README.md', // Only delete the rulesets README, not the root README
              '.github/workflows/fork-governance.yaml',
              '.github/workflows/apply-rulesets.yaml'
            ];

            console.log(`Files to remove: ${filesToDelete.join(', ')}`);

            // Delete files one by one
            for (const filePath of filesToDelete) {
              try {
                // Check if file exists
                const fileContent = await github.rest.repos.getContent({
                  owner: forkOwner,
                  repo: forkRepo,
                  path: filePath
                });

                // Delete the file
                await github.rest.repos.deleteFile({
                  owner: forkOwner,
                  repo: forkRepo,
                  path: filePath,
                  message: `Remove template file: ${filePath}`,
                  sha: fileContent.data.sha
                });

                console.log(`‚úì Deleted: ${filePath}`);
              } catch (error) {
                if (error.status === 404) {
                  console.log(`‚ö†Ô∏è File not found: ${filePath}`);
                } else {
                  console.log(`‚ùå Failed to delete ${filePath}: ${error.message}`);
                }
              }
            }

            // Get the current main branch commit
            const mainRef = await github.rest.git.getRef({
              owner: forkOwner,
              repo: forkRepo,
              ref: 'heads/main'
            });
            const currentCommitSha = mainRef.data.object.sha;

            // Get the first commit in the history
            let firstCommitSha = currentCommitSha;
            let commit = await github.rest.git.getCommit({
              owner: forkOwner,
              repo: forkRepo,
              commit_sha: currentCommitSha
            });

            // Walk back to find the first commit
            while (commit.data.parents && commit.data.parents.length > 0) {
              firstCommitSha = commit.data.parents[0].sha;
              commit = await github.rest.git.getCommit({
                owner: forkOwner,
                repo: forkRepo,
                commit_sha: firstCommitSha
              });
            }

            console.log(`Found first commit: ${firstCommitSha}`);

            // Get the current tree (after file deletions)
            const currentCommit = await github.rest.git.getCommit({
              owner: forkOwner,
              repo: forkRepo,
              commit_sha: currentCommitSha
            });

            // Create a single clean commit with the current state
            const cleanCommit = await github.rest.git.createCommit({
              owner: forkOwner,
              repo: forkRepo,
              message: 'Initial commit - forked from aws-app-template',
              tree: currentCommit.data.tree.sha,
              parents: [] // No parents = orphan commit (clean history)
            });

            // Force update main branch to the clean commit
            await github.rest.git.updateRef({
              owner: forkOwner,
              repo: forkRepo,
              ref: 'heads/main',
              sha: cleanCommit.data.sha,
              force: true
            });

            console.log(`‚úì Cleaned up ${filesToDelete.length} template files from main`);
            console.log(`‚úì Created clean commit history with single commit: ${cleanCommit.data.sha}`);
            console.log(`‚úì Repository now has clean history with only essential files`);

            // Update README.md content to reflect the new repository
            try {
              const readmeContent = await github.rest.repos.getContent({
                owner: forkOwner,
                repo: forkRepo,
                path: 'README.md'
              });

              const currentContent = Buffer.from(readmeContent.data.content, 'base64').toString();

              // Update the README content
              const updatedContent = currentContent
                .replace(/Template repo to spin off application on AWS/g, `AWS application repository for ${forkRepo}`)
                .replace(/aws-app-template/g, forkRepo)
                .replace(/cyan-prod\/aws-app-template/g, `${forkOwner}/${forkRepo}`);

              // Create updated README.md
              await github.rest.repos.createOrUpdateFileContents({
                owner: forkOwner,
                repo: forkRepo,
                path: 'README.md',
                message: 'docs: update README.md for new repository',
                content: Buffer.from(updatedContent).toString('base64'),
                sha: readmeContent.data.sha
              });

              console.log(`‚úì Updated README.md content for ${forkRepo}`);
            } catch (error) {
              console.error('Failed to update README.md:', error.message);
            }

            // Update .github/workflows/README.md content to reflect the new repository
            try {
              const workflowsReadmeContent = await github.rest.repos.getContent({
                owner: forkOwner,
                repo: forkRepo,
                path: '.github/workflows/README.md'
              });

              const currentWorkflowsContent = Buffer.from(workflowsReadmeContent.data.content, 'base64').toString();

              // Update the workflows README content
              const updatedWorkflowsContent = currentWorkflowsContent
                .replace(/aws-app-template/g, forkRepo)
                .replace(/cyan-prod\/aws-app-template/g, `${forkOwner}/${forkRepo}`);

              // Create updated .github/workflows/README.md
              await github.rest.repos.createOrUpdateFileContents({
                owner: forkOwner,
                repo: forkRepo,
                path: '.github/workflows/README.md',
                message: 'docs: update .github/workflows/README.md for new repository',
                content: Buffer.from(updatedWorkflowsContent).toString('base64'),
                sha: workflowsReadmeContent.data.sha
              });

              console.log(`‚úì Updated .github/workflows/README.md content for ${forkRepo}`);
            } catch (error) {
              console.error('Failed to update .github/workflows/README.md:', error.message);
            }

      - name: Apply repository rulesets
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_PAT_CLASSIC }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const forkOwner = '${{ steps.repo-info.outputs.owner }}';
            const forkRepo = '${{ steps.repo-info.outputs.repo }}';

            console.log(`\nApplying rulesets to ${forkOwner}/${forkRepo}...\n`);

            const rulesetDir = 'rulesets';
            const rulesetFiles = fs.readdirSync(rulesetDir)
              .filter(file => file.endsWith('.json'));

            const results = [];

            for (const file of rulesetFiles) {
              const filePath = path.join(rulesetDir, file);
              const rulesetConfig = JSON.parse(fs.readFileSync(filePath, 'utf8'));

              console.log(`Processing: ${file} - ${rulesetConfig.name}`);

              try {
                const response = await github.rest.repos.createRepoRuleset({
                  owner: forkOwner,
                  repo: forkRepo,
                  ...rulesetConfig
                });

                console.log(`‚úì Applied: ${rulesetConfig.name} (ID: ${response.data.id})`);
                results.push({ file, status: 'success', name: rulesetConfig.name });
              } catch (error) {
                console.error(`‚úó Failed: ${rulesetConfig.name} - ${error.message}`);
                results.push({ file, status: 'failed', name: rulesetConfig.name, error: error.message });
              }
            }

            const successCount = results.filter(r => r.status === 'success').length;
            const failCount = results.filter(r => r.status === 'failed').length;

            console.log(`\n=== Summary ===`);
            console.log(`Total: ${results.length} | Success: ${successCount} | Failed: ${failCount}`);

            return results;

      - name: Create dev branch from cleaned main and set as default
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_PAT_CLASSIC }}
          script: |
            const forkOwner = '${{ steps.repo-info.outputs.owner }}';
            const forkRepo = '${{ steps.repo-info.outputs.repo }}';

            try {
              // Check if dev branch exists
              await github.rest.repos.getBranch({
                owner: forkOwner,
                repo: forkRepo,
                branch: 'dev'
              });
              console.log('Dev branch already exists');
            } catch (error) {
              if (error.status === 404) {
                console.log('Creating dev branch from cleaned main...');

                // Get main branch ref (now cleaned)
                const mainBranch = await github.rest.repos.getBranch({
                  owner: forkOwner,
                  repo: forkRepo,
                  branch: 'main'
                });

                // Create dev branch from main
                await github.rest.git.createRef({
                  owner: forkOwner,
                  repo: forkRepo,
                  ref: 'refs/heads/dev',
                  sha: mainBranch.data.commit.sha
                });

                console.log('‚úì Dev branch created from cleaned main');
              } else {
                throw error;
              }
            }

            // Set dev as default branch
            try {
              await github.rest.repos.update({
                owner: forkOwner,
                repo: forkRepo,
                default_branch: 'dev'
              });
              console.log('‚úì Set dev as default branch');
            } catch (error) {
              console.error('Failed to set default branch:', error.message);
              throw new Error(`Failed to set dev as default branch: ${error.message}`);
            }

      - name: Create environments
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_PAT_CLASSIC }}
          script: |
            const forkOwner = '${{ steps.repo-info.outputs.owner }}';
            const forkRepo = '${{ steps.repo-info.outputs.repo }}';

            const environments = ['dev', 'staging', 'prod'];

            const failedEnvs = [];
            for (const env of environments) {
              try {
                await github.rest.repos.createOrUpdateEnvironment({
                  owner: forkOwner,
                  repo: forkRepo,
                  environment_name: env
                });
                console.log(`‚úì Created environment: ${env}`);
              } catch (error) {
                console.error(`Failed to create ${env}:`, error.message);
                failedEnvs.push(env);
              }
            }

            if (failedEnvs.length > 0) {
              throw new Error(`Failed to create environments: ${failedEnvs.join(', ')}`);
            }

      - name: Enable security features
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_PAT_CLASSIC }}
          script: |
            const forkOwner = '${{ steps.repo-info.outputs.owner }}';
            const forkRepo = '${{ steps.repo-info.outputs.repo }}';

            const failedFeatures = [];

            // Enable vulnerability alerts
            try {
              await github.rest.repos.enableVulnerabilityAlerts({
                owner: forkOwner,
                repo: forkRepo
              });
              console.log('‚úì Enabled vulnerability alerts');
            } catch (error) {
              console.error('Failed to enable vulnerability alerts:', error.message);
              failedFeatures.push('vulnerability alerts');
            }

            // Enable automated security fixes (Dependabot)
            try {
              await github.rest.repos.enableAutomatedSecurityFixes({
                owner: forkOwner,
                repo: forkRepo
              });
              console.log('‚úì Enabled Dependabot security updates');
            } catch (error) {
              console.error('Failed to enable Dependabot:', error.message);
              failedFeatures.push('Dependabot security updates');
            }

            // Enable auto-delete head branches
            try {
              await github.rest.repos.update({
                owner: forkOwner,
                repo: forkRepo,
                delete_branch_on_merge: true
              });
              console.log('‚úì Enabled auto-delete branch after merge');
            } catch (error) {
              console.error('Failed to enable auto-delete:', error.message);
              failedFeatures.push('auto-delete branch');
            }

            if (failedFeatures.length > 0) {
              throw new Error(`Failed to enable security features: ${failedFeatures.join(', ')}`);
            }

      - name: Check required files updated
        id: check-files
        uses: actions/github-script@v8
        continue-on-error: true
        with:
          github-token: ${{ secrets.GH_PAT_CLASSIC }}
          script: |
            const forkOwner = '${{ steps.repo-info.outputs.owner }}';
            const forkRepo = '${{ steps.repo-info.outputs.repo }}';

            const requiredFiles = ['README.md', 'CONTRIBUTING.md'];
            const warnings = [];

            for (const file of requiredFiles) {
              try {
                const { data } = await github.rest.repos.getContent({
                  owner: forkOwner,
                  repo: forkRepo,
                  path: file
                });

                const content = Buffer.from(data.content, 'base64').toString();

                // Check if file still contains template placeholder text
                if (file === 'README.md') {
                  if (content.includes('Template repo to spin off application on AWS')) {
                    warnings.push('README.md still contains template text - needs customization');
                  }
                }

                if (file === 'CONTRIBUTING.md') {
                  if (content.includes('aws-app-template')) {
                    warnings.push('CONTRIBUTING.md still references template name - needs update');
                  }
                }

                console.log(`‚úì ${file} exists`);
              } catch (error) {
                warnings.push(`${file} is missing`);
                console.error(`‚úó ${file} not found`);
              }
            }

            core.setOutput('warnings', warnings.join('; '));
            return warnings;

      - name: Create setup notification issue
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_PAT_CLASSIC }}
          script: |
            const forkOwner = '${{ steps.repo-info.outputs.owner }}';
            const forkRepo = '${{ steps.repo-info.outputs.repo }}';
            const nameValid = '${{ steps.validate-name.outputs.valid }}';
            const nameIssues = '${{ steps.validate-name.outputs.issues }}';
            const nameSuggestion = '${{ steps.validate-name.outputs.suggestion }}';
            const fileWarnings = '${{ steps.check-files.outputs.warnings }}';

            let body = `# üéâ Repository Setup Complete\n\n`;
            body += `This repository has been forked from the AWS app template and governance rules have been applied.\n\n`;

            // Naming validation
            body += `## üìù Repository Naming\n\n`;
            if (nameValid === 'true') {
              body += `‚úÖ **Repository name follows convention**: \`${forkRepo}\`\n\n`;
            } else {
              body += `‚ö†Ô∏è **Repository name does NOT follow convention**\n\n`;
              body += `**Current name:** \`${forkRepo}\`\n`;
              body += `**Issues:** ${nameIssues}\n`;
              body += `**Suggested name:** \`${nameSuggestion}\`\n\n`;
              body += `**Convention:** Repository names must:\n`;
              body += `- Start with \`aws-\`\n`;
              body += `- Use lowercase letters only\n`;
              body += `- Use kebab-case (hyphens, not underscores)\n`;
              body += `- Example: \`aws-user-service\`, \`aws-payment-api\`\n\n`;
              body += `To rename: **Settings** ‚Üí **General** ‚Üí **Repository name**\n\n`;
            }

            // Applied rules
            body += `## üîí Applied Governance Rules\n\n`;
            body += `The following rulesets have been applied:\n\n`;
            body += `- ‚úÖ **Branch Protection** - \`main\` and \`dev\` require PR approval\n`;
            body += `- ‚úÖ **Tag Protection** - \`v*\` tags cannot be force-pushed or deleted\n`;
            body += `- ‚úÖ **Branch Naming** - Must follow \`type/jira-123\` pattern (lowercase, kebab-case)\n`;
            body += `- ‚úÖ **Commit Messages** - Must follow \`jira-123: description\` pattern (lowercase)\n\n`;

            // Required status checks
            body += `## ‚öôÔ∏è Required Status Checks\n\n`;
            body += `Before merging to \`main\` or \`dev\`, these checks must pass:\n\n`;
            body += `- \`pr-checks\` - Linting, formatting, testing\n`;
            body += `- \`static-code-scan\` - Security and code quality scanning\n`;
            body += `- \`terraform-plan\` - Infrastructure validation\n\n`;
            body += `**Action Required:** Create these workflow files in \`.github/workflows/\`\n\n`;

            // Branch setup
            body += `## üåø Branch Setup\n\n`;
            body += `- ‚úÖ \`main\` - Production branch (protected)\n`;
            body += `- ‚úÖ \`dev\` - Development branch (protected, **default**)\n\n`;

            // Environment setup
            body += `## üåç Environments Created\n\n`;
            body += `- ‚úÖ \`dev\` - Development environment\n`;
            body += `- ‚úÖ \`staging\` - Staging environment\n`;
            body += `- ‚úÖ \`prod\` - Production environment\n\n`;
            body += `Configure environment-specific settings in **Settings** ‚Üí **Environments**\n\n`;

            // Security features
            body += `## üîí Security Features Enabled\n\n`;
            body += `- ‚úÖ Vulnerability alerts\n`;
            body += `- ‚úÖ Dependabot security updates\n`;
            body += `- ‚úÖ Auto-delete branch after merge\n\n`;

            // Cleanup
            body += `## üßπ Template Files Cleaned Up\n\n`;
            body += `The following template-specific files have been automatically removed:\n`;
            body += `- \`rulesets/\` directory - Rulesets already applied to this repo\n`;
            body += `- \`.github/workflows/fork-governance.yaml\` - No longer needed\n`;
            body += `- \`.github/workflows/apply-rulesets.yaml\` - No longer needed\n\n`;
            body += `**Note:** All governance rules are already active via GitHub Rulesets (check Settings ‚Üí Rules ‚Üí Rulesets)\n\n`;

            // Required files check
            if (fileWarnings) {
              body += `## ‚ö†Ô∏è Required Files Need Attention\n\n`;
              const warningList = fileWarnings.split('; ');
              for (const warning of warningList) {
                body += `- ‚ö†Ô∏è ${warning}\n`;
              }
              body += `\n**Action Required:** Update these files with your project-specific information.\n\n`;
            } else {
              body += `## ‚úÖ Required Files\n\n`;
              body += `- ‚úÖ README.md exists\n`;
              body += `- ‚úÖ CONTRIBUTING.md exists\n\n`;
            }

            // Next steps
            body += `## üöÄ Next Steps\n\n`;
            if (nameValid !== 'true') {
              body += `1. **Fix repository name** (see naming section above)\n`;
            }
            if (fileWarnings) {
              body += `1. **Update required files** (see warnings above)\n`;
            }
            body += `1. **Create required workflow files** for status checks:\n`;
            body += `   - \`.github/workflows/pr-checks.yaml\`\n`;
            body += `   - \`.github/workflows/static-code-scan.yaml\`\n`;
            body += `   - \`.github/workflows/terraform-plan.yaml\`\n`;
            body += `1. **Customize README.md** with your project details\n`;
            body += `1. **Configure environments** in Settings ‚Üí Environments (add secrets, protection rules)\n`;
            body += `1. **Set up AWS credentials** in repository secrets\n`;
            body += `1. **Start developing** - create feature branches following \`type/jira-123\` pattern\n\n`;

            // PR template
            body += `## üìù Pull Request Template\n\n`;
            body += `A PR template has been included at \`.github/pull_request_template.md\`\n`;
            body += `It will automatically appear when creating PRs and is **enforced by code review**.\n\n`;

            // Documentation
            body += `## üìö Documentation\n\n`;
            body += `- [Contributing Guidelines](./CONTRIBUTING.md)\n`;
            body += `- [Repository Rulesets](./rulesets/README.md)\n`;
            body += `- [Architecture Diagram](./docs/architect.drawio.png)\n\n`;
            body += `---\n\n`;
            body += `*This issue was automatically created by the Fork Governance workflow.*`;

            // Create the issue
            const labels = ['setup'];
            if (nameValid !== 'true' || fileWarnings) {
              labels.push('action-required');
            }
            if (nameValid !== 'true') {
              labels.push('naming-convention');
            }
            if (fileWarnings) {
              labels.push('documentation');
            }

            const issue = await github.rest.issues.create({
              owner: forkOwner,
              repo: forkRepo,
              title: (nameValid !== 'true' || fileWarnings)
                ? '‚ö†Ô∏è Repository Setup Complete - Action Required'
                : '‚úÖ Repository Setup Complete - Review Governance Rules',
              body: body,
              labels: labels
            });

            console.log(`‚úì Created issue #${issue.data.number}: ${issue.data.html_url}`);

      - name: Notify in template repo
        uses: actions/github-script@v8
        with:
          script: |
            const forkFullName = '${{ steps.repo-info.outputs.full_name }}';
            const forkUrl = '${{ steps.repo-info.outputs.url }}';

            console.log(`Fork created: ${forkFullName}`);
            console.log(`URL: ${forkUrl}`);
            console.log('‚úì Governance rules applied successfully');
